---
layout: default
title: Plasma FAQ
---
<!--
Copyright (C) 2015-2016 Paul Bone
Licensed as CC BY-NC-ND 4.0
-->

<h1>FAQ</h1>

<dl>
<dt>What is it written in?
<dd>
<p><a href="http://mercurylang.org">Mercury</a>,
until it can be bootstrapped, then hopefully Plasma

<dt>What license is it distributed under?
<dd>
<p>Different parts of Plasma are distributed under different licenses.
The code is almost all the MIT licese with some small parts LGPL.
See the
<a href="https://github.com/PlasmaLang/plasma/blob/master/LICENSE">LICENSE
  file</a>
for more information.

<dt>You work on <a href="http://mercurylang.org">Mercury</a> already,
so is this Mercury 2.0?
<dd>
<p>No.
While it's fair to say that Plasma is related to Mercury (they're both
declaratively pure strongly typed eager languages);
My goals for Plasma are different from the goals of Mercury.
With Plasma I aim to create a compromise between declarative
languages (Like Mercury and Haskell) and imperative languages
like C, Java and Go.
Plasma's syntax looks more like an imperative language, while it's type
system and pure semantics are more like a declarative language.
Plasma is not a logic programming language.

<dt>Why are you writing it?
<dd>
<p>I believe that purely-declarative strongly statically typed languages are the
only sensible option for creating reliable software.
However the two main options Haskell and Mercury have several problems,
including being difficult to learn.
Additionally imperative programming provides some specific advantages over
declarative programming, for example the convenience of expressing loops
directly in the language's syntax and manipulating data in arrays.
I also have some exciting plans for parallel and concurrent programming.

<p>I'm writing Plasma because I believe that we need an easy-to-learn-and-use
purely-declarative language that doesn't make arrays and loops awkward to
use.

<dt>Why the name Plasma?
<dd>
<p>Plasma refers to the fourth state of matter.
The name Plasma comes from a very far-away goal I have for parallel
computing.  This is so far away that it's not practical to talk about it
right now.

<p>Plasma is also good for creating several puns, eg: Plasma is so hot right
now.

<dt>What paradigm is it?
<dd>
<p>We call it a "side-effect free language",
however this is just another way of saying
"purely functional"
but without emphasising <i>functional</i>.
We do this to avoid giving readers the wrong
impression,
since we do not want to emphasise category theory.
</p>
<p>
Like pure functional languages
Plasma code cannot have side effects.
Unlike functional languages we declare affects in terms of
resources,
and Plasma's syntax looks more like a procedural language which should make it
more familiar to more people.
It will be strongly statically typed (a type system similar to Haskell,
Mercury or OCaml's)
and use eager evaluation (like OCaml or Mercury).

<dt>If it is pure, how do you handle effects?  Are there monads?
<dd>
<p>Monads are not used to handle effects as they are in Haskell,
and unlike Mercury and Clean I do not plan to use uniqueness typing to
manage effects.
My colleague
<a href="http://people.eng.unimelb.edu.au/schachte/">Peter Schachte</a>
created a concept called Resources for his language
<a href="http://people.eng.unimelb.edu.au/schachte/papers/wybeintro.pdf">Wybe</a>.
I intend to extend this concept a little further and use it to manage
effects.

<p>Monads are useful and may be supported, but will not be used for
effects or to the extent that they are in Haskell.

<dt>Does/will it have/support <i>X</i>?</dt>
<dd>
  <dl>
    <dt>Threads, channels, mvars, futures and similar?</dt>
    <dd>Yes, not implemented yet.</dd>

    <dt>Green threads?</dt>
    <dd>
    The threading model will be N:M, meaning that greenthreads will be
    used and multiplexed onto native threads.
    </dd>

    <dt>Type classes or parametric modules?</dt>
    <dd>
    We're working <a href="docs/plasma_ref.html#interfaces">interfaces</a>
    which combine benefits of both type classes and parametric modules.
    </dd>

    <dt>Higher kinded types?</dt>
    <dd>Probably, I think they'll be useful for loops.</dd>
  </dl>

  <p>
  Other planned features are described in the
  <a href="roadmap.html">roadmap</a>.
  </p>

</dd>

<dt>What is the intended purpose?  Web programming / scripting / systems?
<dd>
<p>I really don't like these separations.
A good language with a good implementation should be suitable in many
environments.
A more practical question is can a given domain be modeled easily in Plasma?
Another relevant question is can Plasma be used in a given environment?

<dt>Can a given domain be modeled easily in Plasma?
<dd>
<p>Good question!  I hope that Plasma will be very good at problems of a
symbolic nature: most non-numeric problems, the kind of problems that
benefit from a type system like Haskell's.
I also hope that Plasma will be good at numerical problems: simulations and
scientific computing.

<dt>Can Plasma be used in a given environment?  (OS support? scalability?)
<dd>
<p>I develop on Debian Linux on x86_64, using Mercury and GCC.
Occasionally I test using Clang and/or x86.
Development is at a rather early stage, performance is not relevant at this
stage, but we are keeping performance and scalability (up and down) in mind.

<dt>Will it have a JavaScript/Ruby/X backend?
<dd>
<p>I would prefer to have only a small number of backends to maintain.
That said I think the following backends would be valuable and I hope to
support them:
bytecode, native code (or LLVM) and WebAssembly.
However, our bytecode intermediate format allows other developers to write
bytecode interpreters (or translators) for their favorite environments.

</dl>

